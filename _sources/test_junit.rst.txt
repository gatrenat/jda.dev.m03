##########################
Proves unitàries amb JUnit
##########################

Aquesta secció t'introduirà un dels *frameworks* més utilitzats per a
la prova unitària: XUnit.

XUnit és el nom amb el que es coneix una família d'entorns de prova
unitària amplament coneguda entre els desenvolupadors de programari.
Aquest nom es deriva de JUnit, el primer d'aquests entorns en ser ben
conegut. En aquest cas, la *J* vol dir *Java*, i és l'entorn que farem
servir aquí [#articlefowler]_.

El lloc oficial de JUnit és `http://www.junit.org
<http://www.junit.org>`_ i podràs trobar respostes a diverses
qüestions bàsiques com ara, com instal·lo a
`http://junit.sourceforge.net/doc/faq/faq.htm
<http://junit.sourceforge.net/doc/faq/faq.htm>`_.

Si has seguit els darrers blocs d'aquests continguts, ja disposes d'una
instaŀlació adequada de *Junit*.
Altrament, revisa els :doc:`continguts <moduls_junit>`.

JUnit des de línia de comandes
==============================

Com és habitual en aquests continguts, realitzarem les proves des de línia
de comandes. Per descomptat, si vols configurar-te el teu IDE favorit, ho
pots fer i adaptar les passes que et descriuré a continuació a la teva
configuració.

Per executar JUnit des de consola, farem:

.. code-block:: console

    $ java org.junit.platform.console.ConsoleLauncher -h

    Thanks for using JUnit! Support its development at https://junit.org/sponsoring

    Usage: ConsoleLauncher [-h] [--disable-ansi-colors] [--disable-banner]
                           [--fail-if-no-tests] [--scan-modules] [--scan-classpath[=PATH[;|:
                           PATH...]]]... [--details=MODE] [--details-theme=THEME]
                           [--reports-dir=DIR] [-c=CLASS]... [--config=KEY=VALUE]... [-cp=PATH
                           [;|:PATH...]]... [-d=DIR]... [-e=ID]... [-E=ID]...
                           [--exclude-package=PKG]... [-f=FILE]... [--include-package=PKG]...
                           [-m=NAME]... [-n=PATTERN]... [-N=PATTERN]... [-o=NAME]...
                           [-p=PKG]... [-r=RESOURCE]... [-t=TAG]... [-T=TAG]... [-u=URI]...
    Launches the JUnit Platform from the console.
      -h, --help                 Display help information.
          --disable-ansi-colors  Disable ANSI colors in output (not supported by all
                                   terminals).
          --disable-banner       Disable print out of the welcome message.
          --details=MODE         Select an output details mode for when tests are executed.
                                   Use one of: none, summary, flat, tree, verbose. If 'none'
                                   is selected, then only the summary and test failures are
                                   shown. Default: tree.
          --details-theme=THEME  Select an output details tree theme for when tests are
    …

He suprimit part de la sortida per brevetat.

Provem la classe ``Punt``
=========================

Passem ara a provar una classe molt bàsica: la classe ``Punt``. Ho farem
seguint els principis del desenvolupament dirigit per la prova o *TDD*.

En primer lloc, crearem la classe de test ``TestPunt``. Sí, creem el
text abans de crear la classe!

.. code-block:: java
    :linenos:

    import org.junit.jupiter.api.Test;
    public class TestPunt {
        @Test
        public void constructor() {
            // comprova que Punt() pugui ser cridat
            new Punt();
        }
    }

Ara compilem 

.. code-block:: console
    :linenos:

    $ javac TestPunt.java 
    TestPunt.java:6: error: cannot find symbol
            new Punt();
                ^
      symbol:   class Punt
      location: class TestPunt
    1 error

Com era previsible, tenim un error de compilació: no troba la classe
``Punt``. Recorda que l'objectiu d'una prova és sempre trobar un error.
Hem fet fallar el nostre primer test. Per tant **felicitats**!

Afegim ara la classe ``Punt``, amb el codi **estrictament** necessari per
corregir el problema anterior i passar el nostre primer test.

.. code-block:: java
   :linenos:

   public class Punt {}

Compilem i ara sí ens passa ``javac``.

Ara toca executar els tests. En comptes d'invocar ``java`` de la manera
habitual, ho farem de la següent manera:

.. code-block:: console
   :emphasize-lines: 18, 22, 23

    $ java org.junit.platform.console.ConsoleLauncher -c TestPunt

    Thanks for using JUnit! Support its development at https://junit.org/sponsoring

    ╷
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     └─ constructor() ✔
    └─ JUnit Vintage ✔

    Test run finished after 58 ms
    [         3 containers found      ]
    [         0 containers skipped    ]
    [         3 containers started    ]
    [         0 containers aborted    ]
    [         3 containers successful ]
    [         0 containers failed     ]
    [         1 tests found           ]
    [         0 tests skipped         ]
    [         1 tests started         ]
    [         0 tests aborted         ]
    [         1 tests successful      ]
    [         0 tests failed          ]


Molt bé! Sembla que hem passat el nostre primer test.

La sortida que ens genera és molt similar a la que ja ens té acostumat
``prgtest``

El més important ara és veure que ens diu que:

* el nombre de tests trobats és 1

* el nombre de tests que passen també és 1

* el nombre de tests que fallen és 0

No és gaire impressionant, tenint en comptes que bàsicament estem cridant
al constructor per defecte. Potser va sent hora de fer alguna cosa més.

El ``Punt`` té la coordenada ``x``
==================================

Fem un nou test, ara una mica més sofisticat: mirarem que els atributs
d'un punt siguin inicialitzats correctament pel constructor per
defecte. De moment ens centrarem en la coordenada ``x``.

Novament començarem per la prova.

.. code-block:: java
    :linenos:
    :emphasize-lines: 2, 14

    import org.junit.jupiter.api.Test;
    import static org.junit.jupiter.api.Assertions.*;
    public class TestPunt {
        @Test
        public void constructor() {
            // comprova que Punt() pugui ser cridat
            new Punt();
        }

        @Test
        public void constructorDefecteXZero() {
            // comprova que Punt() deixi a 0 la propietat x de Punt
            Punt p = new Punt();
            assertEquals(0, p.getX());
        }
    }

Fixa't en la línia 2. Potser no ho havies vist abans. En Java podem
importar membres estàtics d'aquesta manera. Això ens permet cridar
directament el mètode estàtic ``assertEquals()`` de la línia 14.

Una alternativa seria fer:

.. code-block:: java
    :linenos:
    :emphasize-lines: 2, 14

    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.api.Assertions;
    public class TestPunt {
        @Test
        public void constructor() {
            // comprova que Punt() pugui ser cridat
            new Punt();
        }

        @Test
        public void constructorDefecteXZero() {
            // comprova que Punt() deixi a 0 la propietat x de Punt
            Punt p = new Punt();
            Assertions.assertEquals(0, p.getX());
        }
    }

Com que ``assertEquals()`` està molt associat a ``JUnit``, és poc probable
que anomenem un mètode nostre d'aquesta manera. Així que podem
estalviar-nos afegir ``Assertions`` per tot arreu.

Molt bé, però… què és aquest ``assertEquals()``? Aquest mètode es pot
llegir:

    Afirmo que 0 i ``p.getX()`` valen el mateix.

O si vols de manera més natural:

    Afirmo què la coordenada ``x`` del punt val ``0``

Quan afirmem una cosa així, ``assertEquals()`` comprovarà que els dos
valors que rep siguin iguals. Si ho són, no fa res però si no, llençarà
l'error ``AssertionFailedError``.

Veiem com funciona.

En primer lloc ens caldrà completar ``Punt`` ja que altrament no es podrà
compilar.

Inclou el següent codi:

.. code-block:: java
   :linenos:

   public class Punt {
       public int getX() { return 1; }
   }

Compila i executa els tests:

.. code-block:: console
   :emphasize-lines: 8, 12, 15

    $ javac *.java && java org.junit.platform.console.ConsoleLauncher -c TestPunt

    Thanks for using JUnit! Support its development at https://junit.org/sponsoring

    ╷
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     ├─ constructorDefecteXZero() ✘ expected: <0> but was: <1>
    │     └─ constructor() ✔
    └─ JUnit Vintage ✔

    Failures (1):
      JUnit Jupiter:TestPunt:constructorDefecteXZero()
        MethodSource [className = 'TestPunt', methodName = 'constructorDefecteXZero', methodParameterTypes = '']
        => org.opentest4j.AssertionFailedError: expected: <0> but was: <1>
           org.junit.jupiter.api.AssertionUtils.fail(AssertionUtils.java:55)
           org.junit.jupiter.api.AssertionUtils.failNotEqual(AssertionUtils.java:62)
           org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:150)
           org.junit.jupiter.api.AssertEquals.assertEquals(AssertEquals.java:145)
           org.junit.jupiter.api.Assertions.assertEquals(Assertions.java:510)
           TestPunt.constructorDefecteXZero(TestPunt.java:14)
           java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
           java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
           java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
           java.base/java.lang.reflect.Method.invoke(Method.java:566)
           [...]

    Test run finished after 103 ms
    [         3 containers found      ]
    [         0 containers skipped    ]
    [         3 containers started    ]
    [         0 containers aborted    ]
    [         3 containers successful ]
    [         0 containers failed     ]
    [         2 tests found           ]
    [         0 tests skipped         ]
    [         2 tests started         ]
    [         0 tests aborted         ]
    [         1 tests successful      ]
    [         1 tests failed          ]

Fixa't com ens diu el missatge ``s'esperava <0> però ha estat <1>``.

Sembla que no li ha agradat gaire que retornem un ``1``, oi?

Arreglem ``Punt`` perquè passi la prova:

.. code-block:: java
   :linenos:

   public class Punt {
       public int getX() { return 0; }
   }

I ara sí:

.. code-block:: console

    $ javac *.java && java org.junit.platform.console.ConsoleLauncher -c TestPunt

    Thanks for using JUnit! Support its development at https://junit.org/sponsoring

    ╷
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     ├─ constructorDefecteXZero() ✔
    │     └─ constructor() ✔
    └─ JUnit Vintage ✔

    Test run finished after 65 ms
    [         3 containers found      ]
    [         0 containers skipped    ]
    [         3 containers started    ]
    [         0 containers aborted    ]
    [         3 containers successful ]
    [         0 containers failed     ]
    [         2 tests found           ]
    [         0 tests skipped         ]
    [         2 tests started         ]
    [         0 tests aborted         ]
    [         2 tests successful      ]
    [         0 tests failed          ]



D'aquesta manera anem codificant els tests i després la part de la
classe que calgui per passar-los. Això, segons els de TFD ens
garanteix que tot el que anem desenvolupant sempre és estable i què
mai no desenvolupem de més.

|exerciseicon__T| :doc:`exercici_52_03_coordenada_y`

El punt té un *setter* per X
============================

Seguim afegint funcionalitat a ``Punt``. En aquesta ocasió afegirem el
mètode ``setX()``

Començarem com sempre pel test:

.. code-block:: java
    :linenos:

    // …
    public class TestPunt {
        // …
        @Test
        public void setX42() {
            Punt p = new Punt();
            p.setX(42);
            assertEquals(42, p.getX());
        }
    }

Per descomptat, no compilarà. Ens toca crear el mètode ``setX()`` que
novament farem perquè només passi la prova.

De moment, afegirem el mètode així:

.. code-block:: java
    :linenos:

    public class Punt {
        // …
        public void setX(int x) {
        }
    }

En executar el test, ens trobem amb:

.. code-block:: console
   :emphasize-lines: 9

    $ javac *.java && java org.junit.platform.console.ConsoleLauncher -c TestPunt
    …
    ╷
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     ├─ constructorDefecteXZero() ✔
    │     ├─ constructorDefecteYZero() ✔
    │     ├─ constructor() ✔
    │     └─ setXNoZero() ✘ expected: <42> but was: <0>
    └─ JUnit Vintage ✔
    …

Ops! És clar, el ``42`` no el tenim en lloc. Cap problema, canviem el
``getX()``:

.. code-block:: java
    :linenos:

    public class Punt {
        public int getX() {
            return 42;
        }
        // …
        public void setX(int x) {
        }
    }

Ara tenim:

.. code-block:: console
   :emphasize-lines: 4

    $ javac *.java && java org.junit.platform.console.ConsoleLauncher -c TestPunt
    …
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     ├─ constructorDefecteXZero() ✘ expected: <0> but was: <42>
    │     ├─ constructor() ✔
    │     └─ setX42() ✔
    ├─ JUnit Vintage ✔
    └─ JUnit Platform Suite ✔
    …

Vaja! Passem un test però fallem en un altre!

Això ens obliga a fer una mica de revisió al nostre codi. Com podrem fer
que ``getX()`` ens retorni ``0`` quan no hem cridat a ``setX()`` i ``42``
quan sí? És clar, una propietat:

.. code-block:: java
    :linenos:

    public class Punt {
        private int x = 0;
        public int getX() {
            return x;
        }
        // …
        public void setX(int x) {
            this.x = x;
        }
    }

Amb això passem novament totes les proves!

|exerciseicon__T| :doc:`exercici_52_04_setter_y`

Un constructor específic per ``Punt``
=====================================

Ara ja podem assignar a una instància de ``Punt`` les coordenades que ens
sembli. Seria, però, interessant poder disposar d'un constructor que ens
inicialitzi les coordenades sense haver de fer ús dels *setters*.

Com sempre, comencem amb el test que, en aquest cas, sembla força obvi,
no?

.. code-block:: java
   :linenos:

    // …
    public class TestPunt {
        // …

        @Test
        public void constructorEspecific() {
            Punt p = new Punt(1, 2);
            assertEquals(1, p.getX());
            assertEquals(2, p.getY());
        }
    }

Per descomptat això ens generarà un error de compilació ja que no disposem
del constructor específic. Cap problema, l'afegim:

.. code-block:: java
   :linenos:

    public class Punt {
        private int x = 0;
        // …
        public Punt(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

Potser ja estàvem esperant veure passar les proves quan ens trobem una
sèrie d'errors inesperats en temps de compilació! Ops

.. code-block:: console

    $ javac *.java
    TestPunt.java:7: error: constructor Punt in class Punt cannot be applied to given types;
            new Punt();
            ^
      required: int,int
      found: no arguments
      reason: actual and formal argument lists differ in length
    TestPunt.java:13: error: constructor Punt in class Punt cannot be applied to given types;
            Punt p = new Punt();
                     ^
      required: int,int
      found: no arguments
      reason: actual and formal argument lists differ in length
    TestPunt.java:20: error: constructor Punt in class Punt cannot be applied to given types;
            Punt p = new Punt();
                     ^
      required: int,int
      found: no arguments
      reason: actual and formal argument lists differ in length
    TestPunt.java:26: error: constructor Punt in class Punt cannot be applied to given types;
            Punt p = new Punt();
                     ^
      required: int,int
      found: no arguments
      reason: actual and formal argument lists differ in length
    TestPunt.java:33: error: constructor Punt in class Punt cannot be applied to given types;
            Punt p = new Punt();
                     ^
      required: int,int
      found: no arguments
      reason: actual and formal argument lists differ in length
    5 errors

Vaja. Ens hem oblidat que si afegim el constructor específic *perdem* el
de per defecte! Aquests errors, i de més bàsics, passen. Pe això fem els
tests!

Només cal afegir el constructor per defecte i ja passem les proves.

Més d'un *assert* per test?
===========================

Recordem el darrer test:

.. code-block:: java
   :linenos:

    // …
    public class TestPunt {
        // …

        @Test
        public void constructorEspecific() {
            Punt p = new Punt(1, 2);
            assertEquals(1, p.getX());
            assertEquals(2, p.getY());
        }
    }

Fixa't que estem afegint més d'un *assert* al mateix test. En general no
és una bona pràctica, però en casos com aquest podria ser "perdonable".

El problema és que, si fallen els dos *assert*, JUnit serà incapaç de
mostrar-nos els dos errors i només ens dirà que ha fallat el primer.

Per exemple, suposem que el nostre constructor específic l'implementem amb
l'error:

.. code-block:: java
    :linenos:

    public Punt(int x, int y) {}

El resultat de passar el test serà:

.. code-block:: console
    :emphasize-lines: 9

    ╷
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     ├─ constructorDefecteXZero() ✔
    │     ├─ constructorDefecteYZero() ✔
    │     ├─ constructor() ✔
    │     ├─ setX42() ✔
    │     ├─ setY24() ✔
    │     └─ constructorEspecific() ✘ expected: <1> but was: <0>
    └─ JUnit Vintage ✔

Ni rastre de l'error amb ``y``.

JUnit5 ens ofereix un mecanisme que permet salvar aquest problema sense
necessitat de crear un test per cada coordenada. La notació ens pot
resultar desconcertant ja que en aquest curs no hem vist (ni veurem) el
concepte de `expressió lambda
<https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html>`_

.. code-block:: java
    :linenos:

    @Test
    public void constructorEspecific() {
        Punt p = new Punt(1, 2);
        assertAll(
            () -> assertEquals(1, p.getX()),
            () -> assertEquals(2, p.getY())
        );
    }

Fixa't com, els dos *asserts* apareixen com una mena d'arguments de la
crida a ``assertAll()``, precedits per ``() ->`` i, com bons arguments
d'una crida, separats per coma.

Ara, en tornar a executar el test, tenim:

.. code-block:: console
    :emphasize-lines: 9-11

    ╷
    ├─ JUnit Jupiter ✔
    │  └─ TestPunt ✔
    │     ├─ constructorDefecteXZero() ✔
    │     ├─ constructorDefecteYZero() ✔
    │     ├─ constructor() ✔
    │     ├─ setX42() ✔
    │     ├─ setY24() ✔
    │     └─ constructorEspecific() ✘ Multiple Failures (2 failures)
    │              	org.opentest4j.AssertionFailedError: expected: <1> but was: <0>
    │              	org.opentest4j.AssertionFailedError: expected: <2> but was: <0>
    └─ JUnit Vintage ✔

Molt més informatiu, oi?

No tens obligació de fer servir aquesta notació en aquest curs, però
potser està bé si et vas familiaritzant amb ella. El següent exercici
t'ofereix una oportunitat per practicar-la.

Apa, practiquem una mica. 

|exerciseicon__T| :doc:`exercici_52_05_suma`

|exerciseicon__T| :doc:`exercici_52_06_segment`

|exerciseicon__T| :doc:`exercici_52_07_encapsulacio`


Provant coses més complexes
===========================

Amb el que hem vist fins ara, podem provar classes més aviat
senzilletes. Què passa però quan la cosa es complica? Per exemple, com
ens ho fem per comprovar *exceptions*? o bé classes abstractes? o fins
i tot multifil?

La resposta que et donaré ara és… cercant-ho és clar. La lectura
completa de les FAQ ja són un bon punt de partida.

En tot cas, intentarem fer una primera aproximació al "búscate la
vida" que t'estic venent, amb el següent exercici. D'aquesta manera,
espero, tindràs tota la confiança per trobar els *coms* de les teves
necessitats amb els teus mitjans.

|exerciseicon___| :doc:`exercici_52_08_excepcions`

Ampliacions
===========

El món de les proves unitàries és ample. Potser voldràs llegir `The
Way of Testivus
<http://www.agitar.com/downloads/TheWayOfTestivus.pdf>`_ per a
aconseguir una visió més filosòfica i potser entretinguda del món on
t'estàs ficant amb el tema del testeig.

També pot ser-te interessant llegir-te el post del James Carr sobre
els `antipatrons del TDD
<http://blog.james-carr.org/2006/11/03/tdd-anti-patterns/>`_. Allà hi
trobaràs errors típics dels dissenyadors de proves, com ara:

* Definir un munt de proves que el sistema és capaç de passar sense
  donar error, però que si les mires amb detall, no testejen gaire
  cosa.

* Proves que realment només proven que les dades introduïdes per la
  prova són correctes.

* Proves que tinguin en comptes com està el sistema després d'una
  altra prova. Les proves dependents entre si poden provocar problemes
  si no estan ben documentades. Es preferible escriure proves
  autocontingudes, que es realitzin amb el sistema "net"

* Proves que requereixen un munt de preparació per començar a provar,
  fins al punt que es fa difícil saber què és el que es vol provar.

*Happy bug hunting!*

.. rubric:: Anotacions

.. [#articlefowler] Pots trobar més informació a partir 
   d'`aquest article <http://www.martinfowler.com/bliki/Xunit.html>`_
   del Martin Fowler. També, com no, a la `Vikipedia
   <http://en.wikipedia.org/wiki/XUnit>`_ on podràs accedir a una
   ampla `llista d'entorns
   <http://en.wikipedia.org/wiki/List_of_unit_testing_frameworks>`_ de
   prova classificats pel llenguatge de programació.
