##################################
Breu consideració sobre eficiència
##################################

Comparem un altre cop les darreres versions del nostre ``ComptaAiEs``

La versió que crida a ``quantesOcurrencies()`` cada cop que necessita el
valor, sense importar-li si ja s'havia calculat abans:

.. code-block:: java
    :linenos:
    :emphasize-lines: 11, 15, 16

    /* programa que mostra quantes 'a's i 'e's té el text llegit per stdin */
    public class ComptaAiEs {
        public static void main(String[] args) {
            System.out.println("Introdueix un text");
            String entrada = Entrada.readLine();
            comptaLletra(entrada, 'a');
            comptaLletra(entrada, 'e');
            comparaAiEs(entrada);
        }
        public static void comptaLletra(String text, char lletra) {
            int comptador = quantesOcurrencies(text, lletra);
            System.out.println("Nombre de '" + lletra + "'s: " + comptador);
        }
        public static void comparaAiEs(String text) {
            int comptadorA = quantesOcurrencies(text, 'a');
            int comptadorE = quantesOcurrencies(text, 'e');
            if (comptadorA > comptadorE) {
                System.out.println("Hi ha més 'a's que 'e's");
            } else if (comptadorA < comptadorE) {
                System.out.println("Hi ha menys 'a's que 'e's");
            } else {
                System.out.println("Hi ha tantes 'a's com 'e's");
            }
        }
        public static int quantesOcurrencies(String text, char lletra) {
            int comptador = 0;
            for (int i=0; i < text.length(); i++) {
                if (text.charAt(i) == lletra) {
                    comptador += 1;
                }
            }
            return comptador;
        }
    }

En total, en aquest programa es crida dos cops ``quantesOcurrencies()``
per cada vocal, i sempre pel mateix text. El cert és que, un cop ja has
comptat les ``'a'`` que conté un text, per molt que les tornis a comptar,
seguiran havent-hi les mateixes. Malauradament ``quantesOcurrencies()`` no
sap que ja les ha comptades abans i torna a fer el càlcul un altre cop per
obtenir el mateix resultat.

Et proposo la següent versió que cridaria ``quantesOcurrencies()`` el
mínim possible:

.. code-block:: java
    :linenos:
    :emphasize-lines: 6, 7, 12, 15

    /* programa que mostra quantes 'a's i 'e's té el text llegit per stdin */
    public class ComptaAiEs {
        public static void main(String[] args) {
            System.out.println("Introdueix un text");
            String entrada = Entrada.readLine();
            int numAs = quantesOcurrencies(entrada, 'a');
            int numEs = quantesOcurrencies(entrada, 'e');
            mostraOcurrencies('a', numAs);
            mostraOcurrencies('e', numEs);
            mostraComparacio('a', numAs, 'e', numEs);
        }
        public static void mostraOcurrencies(char lletra, int quantes) {
            System.out.println("Nombre de '" + lletra + "'s: " + quantes);
        }
        public static void mostraComparacio(char lletra1, int quantes1, char lletra2, int quantes2) {
            if (quantes1 > quantes2) {
                System.out.println("Hi ha més '" + lletra1 +"'s que '"+lletra2+"'s");
            } else if (quantes1 < quantes2 ) {
                System.out.println("Hi ha menys '" + lletra1 +"'s que '"+lletra2+"'s");
            } else {
                System.out.println("Hi ha tantes '" + lletra1 +"'s com '"+lletra2+"'s");
            }
        }
        public static int quantesOcurrencies(String text, char lletra) {
            int comptador = 0;
            for (int i=0; i < text.length(); i++) {
                if (text.charAt(i) == lletra) {
                    comptador += 1;
                }
            }
            return comptador;
        }
    }

Fixa't que aquesta versió *només* calcula un cop les ocurrències de cada
lletra, i guarda els resultats en les variables temporals ``numAs``
``numEs``, per després passar els valors als procediments
``mostraOcurrencies()`` i ``mostraComparacio()``.

Podríem dir que aquesta versió és més *eficient* que l'anterior, ja que no
torna a realitzar càlculs innecessàriament.

Abans que ens emocionem massa, cal que tinguem present el cost que
representa aquesta *optimització*:

* ens cal guardar els valors en variables temporals. En aquest cas
  ``numAs`` i ``numEs``

* la signatura dels nostres mòduls s'ha complicat. Ara requereixen més
  paràmetres

* l'ús d'aquests mòduls modificats també s'ha complicat: ara requereixen
  comptar les ocurrències abans de ser usats.

Si bé pot resultar molt temptador *optimitzar* els nostres codis, sovint
afegir més complexitat no és una bona idea.

Així doncs, què fem? Optimitzem o no optimitzem?

Com a regla general, evitarem optimitzar massa aviat, especialment si és a
costa de complicar el codi. Un cop finalitzat el programa, i només si la
seva execució resulta massa lenta, passarem a optimitzar tot mirant de
minimitzar la pèrdua de simplicitat.

Vols saber-ne més?
==================

Quan desenvolupem hem de tenir sempre en ment la famosa frase de `Donald
Knuth <https://ca.wikipedia.org/wiki/Donald_Knuth>`_ *Premature
Optimization Is the Root of All Evil* (l'optimització prematura és
l'origen de tots els mals)

L'optimització prematura no és només una cosa de desenvolupadors. Per
exemple, `aquest article
<https://effectiviology.com/premature-optimization/>`_ ho explica des d'un
punt de vista més general.
