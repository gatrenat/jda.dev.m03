################
Tipus de *tipus*
################

Java distingeix entre tipus *primitius* i *referències*. A aquests
últims, sovint ens referirem com a *objectes*.

.. uml::
    :align: center
    :caption: tipus de *tipus* en Java

    @startuml

    hide class circle
    skinparam class {
        BackgroundColor White
        BorderColor Black
        ArrowColor Black
    }

    class "Tipus de dades" as Tipus
    Tipus <|-- Primitiu
    Tipus <|-- Objecte
    hide class circle
    hide class members
    @enduml

Podem entendre els tipus primitius com aquells que disposen d'un valor
directament associat a la variable a la que estan assignats. En canvi, en
el cas dels objectes, les variables no contenen directament el seu valor
sinó que fan *referència* a la posició de memòria [#referencies]_ on està
emmagatzemat el valor.

Per mirar d'entendre-ho, deixa'm que et faci una *simplificació* del model
de memòria que fa servir Java:

* les posicions de memòria seran nombres enters que, per distingir-los,
  aquí els prefixarem amb ``@`` (atenció que no és notació de Java!)

* tots els valors ocupen el mateix en memòria

Per exemple, considera el següent fragment de codi:

.. code-block:: java
   :linenos:

    int edat = 18;
    double pes = 72.16;
    String nom = "Miranda";
    String cognoms = "Garcia Orujo";

Representem aquestes dades en la nostra simplificació de la memòria del
programa:

+------------------+---------+--------------------------+
|   variable       | posició |   valor                  |
+==================+=========+==========================+
|   int edat       | @100    |   ``18``                 |
+------------------+---------+--------------------------+
| double pes       | @101    |   ``72.16``              |
+------------------+---------+--------------------------+
| String nom       | @102    |   ``1000``               |
+------------------+---------+--------------------------+
| String cognoms   | @103    |   ``1001``               |
+------------------+---------+--------------------------+
| …                                                     |
+------------------+---------+--------------------------+
|                  | @1000   |   ``"Miranda"``          |
+                  +---------+--------------------------+
|                  | @1001   |   ``"Garcia Orujo"``     |
+------------------+---------+--------------------------+
| …                                                     |
+------------------+---------+--------------------------+

Així, observem que:

* el valor de la variable ``edat`` estaria guardat a la posició *@100*

* el valor de ``pes`` estaria guardat a la posició *@101*

* el valor de ``nom`` estaria guardat a la posició *@102* però aquí hi
  ha una cosa diferent. El valor de ``nom`` no és l'esperat ``"Miranda"``
  sinó ``1000``!

  El que ha passat aquí és que, ``nom`` no guarda directament el valor del
  String, sinó la posició on es troba aquest valor, en aquest cas *@1000*.

* el valor de ``cognom`` mostra el mateix comportament de ``nom``. No
  és el text sinó una posició on està guardat el text!

Anirem treballant aquests conceptes constantment durant el curs, així que
no pateixis si ho veus una mica confós encara.

Considera el següent diagrama:

.. uml::
    :align: center
    :caption: Esquema *parcial* dels tipus de dades de Java

    @startuml

    hide class circle
    skinparam class {
        BackgroundColor White
        BorderColor Black
        ArrowColor Black
    }

    class "Tipus de dades" as Tipus
    class "Tipus primitiu" as Primitiu
    Tipus <|-- Primitiu
    Tipus <|-- Objecte
    hide class circle
    hide class members

    Primitiu <|-- boolean
    Primitiu <|-- byte
    Primitiu <|-- char
    Primitiu <|-- double
    Primitiu <|-- float
    Primitiu <|-- int
    Primitiu <|-- long
    Primitiu <|-- short

    Objecte <|-- String

    @enduml

.. <|--

El diagrama mostra un bon grapat de tipus primitius, alguns amb els que no
hem treballat encara. D'objectes, però, només en mostra els Strings. Ja
t'avanço que n'hi ha força més!

Permetem-nos una breu repassada, amb alguna ampliació, sobre els tipus primitius

* Els literals de tipus enter en base 10, s'especifiquen directament amb
  el valor. Si ens interessa fer servir altres bases, ho podem fer com als
  següents exemples:

  .. code-block:: java
    :linenos:

        42        // correspon al valor 42 en decimal
        0x2a      // correspon al valor 42 en hexadecimal
        0b101010  // correspon al valor 42 en binari

  Fixa't com simplement afegint ``0x`` i ``0b`` ja estem indicant a Java
  que el valor està representat en hexadecimal i binari (respectivament)

* El tipus ``boolean`` admet només els valors *true* i *false*, escrits
  així, en minúscules.

  Comentar que quan disposem d'un valor de tipus boolean, no cal
  comparar-ho amb *true* per saber si és cert o fals.

  Per exemple, les següents condicions serien equivalents:

  .. code-block:: java
    :linenos:

     boolean esMajorEdat = edat >= 18;
     if (edat >= 18) {
         System.out.println("Podeu anar a la presó");
     }
     if (esMajorEdat == true) {
         System.out.println("Comparant amb true potser *Sí* anireu a la presó ;)");
     }
     if (esMajorEdat) {
         System.out.println("Sense comparar amb true potser us salveu de la presó");
     }

  La segona condició no et deixarà gaire bé davant programador/es amb més
  experiència. La primera és vàlida i la tercera s'entén millor ja que es
  pot llegir de manera natural *si és major d'edat llavors mostra el
  missatge…*.

* El tipus ``int`` es poden quedar curts per representar alguns enters
  grandets. Java ens ofereix un tipus primitiu una mica més gran, anomenat
  ``long``.

  Quan volem explicitar que un literal és ``long``, ho farem acabant-lo amb
  ``l`` o ``L``. Per exemple:

  .. code-block:: java
    :linenos:

        10000000000000000L

* els literals dels tipus numèric amb coma flotant ``float`` els acabarem
  ``f`` o ``F``.  Els ``double`` no necessiten cap marca, però ho podem
  explicitar amb ``d``, o ``D``. També es pot especificar amb notació
  científica, fent servir ``e``. Exemples:

  .. code-block:: java
    :linenos:

        10.5F       // és un float
        100.1D      // és un double
        100.1       // també un double com l'anterior
        1.001e2     // el mateix valor double que l'anterior

  A diferència de la resta de tipus primitius, els numèrics amb coma
  flotant no responen massa bé al comparador d'igualtat ``==``.

  Considera el següent exemple:

  .. code-block:: console
        :emphasize-lines: 2, 5, 8

        jshell> double pes1 = Double.parseDouble(".3");
        pes2 ==> 0.3

        jshell> double pes2 = .1 + .1 + .1;
        pes1 ==> 0.30000000000000004

        jshell> pes1 == pes2;
        $1 ==> false

  Ops! Sembla que sumar tres cops ``.1`` no és exactament ``.3``!

  Una manera senzilla de comparar aquests valors per igualtat és
  establir un llindar a partir del qual considerem els valors iguals

  Considera el següent fragment de codi:

  .. code-block:: console
        :emphasize-lines: 2, 5

        jshell> double LLINDAR = .00000001;
        LLINDAR ==> 1.0E-8

        jshell> boolean pesosIguals = Math.abs(pes1 - pes2) < LLINDAR;
        pesosIguals ==> true

* el tipus ``char`` requereix dos *bytes* i els seus valors es codifiquen en
  Unicode, cosa que ens estalvia molts problemes als que fem servir
  caràcters com la ``'ç'``.

  Podem assignar literals de tipus ``char`` envoltant-los entre cometes
  simples, com als exemples:

  .. code-block:: java
    :linenos:

        char c = 'à';
        c = '\u00e0';   // és el codi Unicode per à o sigui que c continua valent el mateix!

  Podem fer servir alguns caràcters especials, com ara: ``\t`` (tab), ``\n``
  (salt de línia), ``\"`` (cometes dobles), ``\'`` (cometes simples), i ``\\``
  (la pròpia contrabarra).

  .. code-block:: java
    :linenos:

        char ch = '"';
        ch = '\'';     // és el caràcter cometa simple. Cal escapar-ho

* Java tracta el típus caràcter com un valor numèric, de manera que la
  següent interacció amb jshell és possible:

  .. code-block:: console
     :emphasize-lines: 2, 5, 8, 13

     jshell> char ch = 'a';
     ch ==> 'a'

     jshell> System.out.println(ch+1);
     98

     jshell> System.out.println((char)(ch+1));
     b

     jshell> if (ch >= 'a' && ch <= 'z') {
        ...>     System.out.println("És una lletra minúscula de l'alfabet llatí");
        ...> }
     És una lletra minúscula de l'alfabet llatí

  Fixa't com el caràcter ``'a'`` (què té el codi ASCII nr. 97) passa a ser
  considerat com un enter quan se li suma 1 a la línia 5.

  A la línia 8 veiem que podem fer que Java el torni a considerar un
  caràcter si li posem davant ``(char)``. 

  Finalment, la condició de la línia 10 ens mostra com podem fer per mirar
  si ``ch`` es troba entre la ``'a'`` i la ``'z'`` en l'alfabet llatí
  (sense caràcters especials com ara ``'ç'`` o ``'à'``)

* Quan el valor numèric que volem assignar a una variable numèrica es
  troba fora dels límits, el compilador ens donarà un error. Sempre podem
  forçar al compilador a acceptar la conversió malgrat es pugui perdre
  informació


  .. code-block:: console
        :emphasize-lines: 2-5, 8

        jshell> byte b = 256;
        |  Error:
        |  incompatible types: possible lossy conversion from int to byte
        |  byte b = 256;
        |           ^-^

        jshell> byte b = (byte) 256;
        b ==> -24

  A forçar al compilador a acceptar un tipus per un altre es sol anomenar
  *cast*. El compilador és prou llest com per no permetre conversions
  absurdes i, encara que sapiguem enganyar, després en executar-ho, es
  produiria un error.

|exerciseicon___| :doc:`exercici_14_01_tipus_primitius`

-----

.. [#referencies] No és que el valor sigui la posició de memòria on
    s'emmagatzema el text, però per nosaltres és còmode pensar-ho.
