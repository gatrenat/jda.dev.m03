############
Polimorfisme
############

Considera el següent codi:

.. code-block:: java
    :linenos:
    :emphasize-lines: 24, 33, 38, 40

    class Gat {
        public void menja(Menjar menjar) { System.out.println("Gat menja " + menjar); }
        public void miola() { System.out.println("Gat miola"); }
        public void netejaUrpes() { System.out.println("Gat netejaUrpes"); }
        /* … */
    }

    class GatRenat extends Gat {
        @Override
        public void miola() { System.out.println("GatRenat miola"); }

        @Override
        public void menja(Menjar menjar) {
            netejaUrpes();
            super.menja(menjar);
        }

        public void fesDeRenat() { System.out.println("GatRenat fa de Renat"); }
        /* … */
    }

    public class UsaGats {
        /* prepara un menjar pel gat, li ho fa menjar i finalment fa que mioli */
        private static void alimentaGat(Gat gat) {
            Menjar menjar = new Menjar("sardines");
            gat.menja(menjar);
            gat.miola();
        }

        public static void main(String[] args){
             Gat gat = new Gat();
             GatRenat renatI  = new GatRenat();
             Gat renatII = new GatRenat();

             System.out.printf("Alimentant el gat%n");
             alimentaGat(gat);
             System.out.printf("%n%nAlimentant el gat Renat I%n");
             alimentaGat(renatI);
             System.out.printf("%n%nAlimentant el gat Renat II%n");
             alimentaGat(renatII);
        }
    }

Analitzant aquest codi ens trobem amb quelcom molt peculiar. Fixa't en la
línia 33.

.. code-block:: java
    :linenos:
    :lineno-start: 33

     Gat renatII = new GatRenat();

``renatII`` és declarat com una referència a instàncies de tipus ``Gat``
però el que se li assigna és una instancia de tipus ``GatRenat``!

Aquest codi compila i s'executa.  En fer-ho, el resultat és:

.. code-block:: console
    :emphasize-lines: 2-

    $ java UsaGats
    Alimentant el gat
    Gat menja sardines
    Gat miola


    Alimentant el gat Renat I
    Gat netejaUrpes
    Gat menja sardines
    GatRenat miola


    Alimentant el gat Renat II
    Gat netejaUrpes
    Gat menja sardines
    GatRenat miola

Per primer cop en aquest curs Java sembla acceptar que una
referència d'un tipus accepti una instància d'un altre tipus.

La pregunta és, realment es tracta d'un *altre* tipus? I la resposta és
*no ben bé*. Per la definició de ``GatRenat`` com a subclasse de ``Gat``
el que estem dient és que un gat Renat **és** un gat. Això Java s'ho pren
tant seriosament que accepta instàncies de ``GatRenat`` a **tot arreu**
que accepti instàncies de ``Gat``.

A aquesta possibilitat de que una variable pugui fer referència a
instàncies del seu tipus o de les subclasses d'aquest li direm
*polimorfisme*.

Si ens fixem més en el codi, veurem que el procediment ``alimentaGat()``
accepta un paràmetre de tipus ``Gat`` i està prou content quan se li passa
``renatI`` i ``renatII`` que fan referència a instàncies de ``GatRenat``
tant si ha estat declarat com a ``GatRenat`` com si ho ha estat com a
``Gat``.

De fixar-nos encara més, trobarem que ``alimentaGat()``, tot i només saber
de gats, està fent que finalment s'executi els mètodes ``miola()`` i
``menja()`` corresponents a ``GatRenat`` quan el que rep és una instància
de ``GatRenat``. Fixa't que a la sortida tots dos es netegen les urpes
abans de menjar i miolen com a ``GatRenat``.


Tots els gats Renat són gats però no tots els gats són gats Renat.
==================================================================

Hem vist que pel polimorfisme, una variable pot fer referència a una
instància de la seva classe o de qualsevol de les subclasses. També hem
vist que, en cridar un mètode sobreescrit de la instància, acaba sent
executat el corresponent a la classe *real* de la instància i no a la
superclasse.

Què passaria si intentem cridar un mètode vàlid per un ``GatRenat`` des
d'una referència  de tipus ``Gat``?

Considera el següent fragment de codi:

.. code-block:: java
    :linenos:

    GatRenat renat = new GatRenat();
    renat.fesDeRenat();              // cap problema

    Gat gat = new GatRenat();
    gat.fesDeRenat();                // no compila!

El fragment de codi anterior **no** compila. A la línia 5, Java intenta
trobar el mètode ``fesDeRenat()`` a la definició de ``Gat`` però no la
troba. De fet, el problema el detecta el compilador.

Donat que sabem que ``gat`` està fent referència realment a un
``GatRenat``, podríem saltar-nos aquesta *protecció* del compilador de la
següent manera:

.. code-block:: java
    :linenos:
    :lineno-start: 5

    ((GatRenat)gat).fesDeRenat();    // ara sí compila i s'executa bé

En prefixant la referència amb ``(GatRenat)`` estem avisant al compilador
de Java que tracti la referència com a ``GatRenat`` i no com a ``Gat``. El
compilador passa a cercar el mètode a la definició de ``GatRenat`` i, com
la troba, compila sense més queixa.

Però… i si realment no fos un ``GatRenat`` sinó un ``Gat`` i li féssim
creure a Java que és el primer?

.. code-block:: java
    :linenos:

     Gat gat = new Gat();
     ((GatRenat)gat).fesDeRenat();    // sí compila!

Doncs resulta que el compilador de Java s'ho empassa i genera el
``.class``. Quan ho intentem executar, però, la mentida surt a la llum amb
un missatge similar a:

.. code-block:: console

    $ java UsaGats
    Exception in thread "main" java.lang.ClassCastException: class Gat cannot be cast to class GatRenat (Gat and GatRenat are in unnamed module of loader 'app')
        at UsaGats.main(UsaGats.java:55)

És clar, un gat qualsevol per molt que ens hi posem, no pot fer de gat
Renat.

El següent dibuix intenta mostrar-ho gràficament.

.. figure:: _images/cucurutxos.png
   :alt: Metàfora dels cucurutxos
   :align: center

A la imatge veiem com un suport (*variable*) per cucurutxos de tipus
(*classe*) ``A``, pot subjectar (*referenciar*) cucurutxos (*instàncies*) de
tipus ``A``. Aquest mateix suport, és capaç de subjectar cucurutxos que
estenen el tipus ``A``. En canvi, amb el suport pels cucurutxos de tipus
``B``, els de tipus ``A`` ens **caurien** a terra!

Si et costa l'abstracció, substitueix A per ``Gat`` i ``B`` per
``GatRenat``

|exerciseicon__T| :doc:`exercici_04_34_garfield`

