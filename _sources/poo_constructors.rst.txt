############
Constructors
############

Coneixerem ara els *constructors*, un tipus especial de bloc de codi
(*mòdul*) que en programació orientada a objectes és cridat per realitzar
la creació d'una nova instància d'una classe, i que té la funció de
preparar la instància per a ser utilitzada.

Aquesta introducció comença amb una secció *teòrica* que descriu els
constructors (i destructors), per després continuar amb l'anàlisi
d'exercicis en Java.

Però si ja els coneixem!
========================

En realitat ja hem fet servir els constructors. En el tema
:doc:`poo_intro` hem vist codi que fa:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +getVides(): int
     }
     @enduml

.. code-block:: java
    :linenos:
    :emphasize-lines: 6

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

A la línia 6 estem creant o *construint* una instància de ``GatRenat``. Un
cop executada, sabem que la referència ``renat`` queda inicialitzada a un
valor de tipus ``GatRenat``.

Veiem-ho pas a pas començant per la línia 5:

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Podem representar la part que ens interessa de la memòria del programa de
la següent manera:


.. image:: _images/constructors_01.svg
   :align: center
   :width: 50%

``renat`` és una variable. El seu valor de moment és ``null`` i està
allotjat a la posició de memòria ``@100`` associada al nom ``renat``.

De moment no tenim cap gat instanciat. Només un nom (``renat``) que en pot
fer referència. Passem a la següent línia:

.. code-block:: java
    :linenos:
    :emphasize-lines: 6

    public class GatRenat {
        private int vides = 7;
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

.. image:: _images/constructors_02.svg
   :align: center
   :width: 75%

Aquesta representació simplificada ens mostra que l'estat del gat Renat,
del que de moment només ens interessa el valor de la propietat *vides*.

La següent línia crida el mètode ``getVides()`` que retornarà el valor de
``vides`` de la instància referenciada per ``renat``. És a dir, la que hi
ha a la posició ``@1000``.

Ignorant el fet que ``vides`` és privat, ``renat.getVides()`` vindria a
ser equivalent a ``renat.vides``.

.. image:: _images/constructors_03.svg
   :align: center
   :width: 75%


En fer ``renat.getVides()`` la funció *sap* que ``renat`` apunta a la posició
``@100`` i per tant, és capaç de localitzar el seu camp ``vides``, i retornar
el seu valor: ``7``.


Un lleuger canvi
================

Considera ara aquesta nova versió de ``GatRenat`` que té exactament el mateix
resultat que l'anterior:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat()
        +getVides(): int
     }
     @enduml


.. code-block:: java
    :linenos:
    :emphasize-lines: 2-6

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Aquesta nova versió no inicialitza la propietat ``vides`` en la declaració. En
canvi, declara una mena de *mòdul* anomenat igual que la classe, que sí sembla
inicialitzar aquest camp!

Tornem a veure-ho pas a pas començant per la línia 9:

.. code-block:: java
    :linenos:
    :emphasize-lines: 9

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Representem la memòria inicial d'aquesta execució de la mateixa manera que
amb la versió anterior:

.. image:: _images/constructors_01.svg
   :align: center
   :width: 50%

En la següent línia ve quelcom interessant a l'hora de cridar ``new GatRenat()``.

.. code-block:: java
    :linenos:
    :emphasize-lines: 10

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Centrem-nos en el que passa un cop hem arribat a la línia 4 on només tenim
aquest misteriós comentari.

.. code-block:: java
    :linenos:
    :emphasize-lines: 4

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

En el que el codi no ens permet veure, Java ha *designat* un espai de
memòria suficient per emmagatzemar totes les propietats d'una instància de
la classe ``GatRenat`` i les ha inicialitzades al seu valor base. En ser
``vides`` un enter, aquest valor és ``0``.

.. image:: _images/constructors_04.svg
   :align: center
   :width: 75%

La posició d'aquest espai és referenciada per una variable temporal, que
al diagrama hem anomenat ``this``. Li podiem haver dit ``tmp`` però
el nom ``this`` és més significatiu.

Passem a la següent línia d'aquest mòdul tan especial:

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

A la línia 5, el codi demana assignar ``7`` a la variable ``vides``.
Aquesta variable no està definida dins del mòdul i, per tant, podria
semblar que hauria de donar error. Però no ho fa.

No ho fa perquè Java, si no troba ``vides`` en aquest context, intentarà
trobar *una altra* ``vides`` tot afegint-li context. En concret,
reemplaçarà aquesta línia 5 per ``this.vides = 7``.

.. code-block:: java
    :linenos:
    :emphasize-lines: 5

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            this.vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Aquesta nova variable **sí** que existeix! Fa referència a la posició
``@1000.vides``. Així, en executar-la, ens trobem el següent canvi:

.. image:: _images/constructors_05.svg
   :align: center
   :width: 75%

És a dir, el valor corresponent a ``vides`` de l'espai de memòria que ha
estat assignat a la instància, ha passat a tenir el valor ``7``.

Un cop finalitzada l'execució de la línia 5, el mòdul ``GatRenat()`` també
finalitza l'execució. L'operador ``new`` de la línia 10 farà que el
resultat de l'expressió ``new GatRenat()`` sigui el valor de la variable
temporal que hem anomenat ``this``. És a dir ``1000``. Així, en acabar
d'executar la línia 10 tindrem:

.. image:: _images/constructors_02.svg
   :align: center
   :width: 75%

Tot plegat, estem en la mateixa situació que amb la versió del programa en
que la inicialització de ``vides`` es feia en la mateixa declaració.

Passem ara a la següent línia:

.. code-block:: java
    :linenos:
    :emphasize-lines: 11

    public class GatRenat {
        private int vides;
        public GatRenat() {
            // (altres coses del constructor que no es veuen)
            vides = 7;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

En comptes de saltar-nos l'execució de ``getVides()`` ara *entrarem a
dins*.

Per poder entendre bé com es produeix aquesta crida, ens caldrà fer un
petit canvi *sintàctic*. ``renat.getVides()`` és una crida a una funció,
com sabem. Però no deixa de resultar estrany que ``renat``, una
referència a una instància de tipus ``GatRenat``, estigui abans de
``getVides()`` com si aquesta fos una de les propietats de ``GatRenat``
però sent codi. Estrany, oi?

Intentem-ho veure amb aquesta permutació:

    ``renat.getVides()`` → ``GatRenat.getVides(renat)``

**Atenció**: ``GatRenat.getVides(renat)`` no és vàlid en Java tal i com
està definit ``getVides()``.

Per que la transformació funcionés, ens caldria declarar ``getVides()``
de la següent manera:

.. code-block:: java
    :linenos:
    :emphasize-lines: 4-6, 10

    public class GatRenat {
        private int vides;
        public GatRenat() { vides = 7; }
        public static int getVides(GatRenat aquest) {
            return aquest.vides;
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat();
            int vides = GatRenat.getVides(renat);
            System.out.printf("Vides: %d%n", vides);
        }
    }

**Nota**: he hagut de posar-li ``aquest`` en comptes de ``this`` perquè
Java té reservat aquest nom i em donaria error.

Ara, en entrar a ``getVides()`` ens trobaríem la següent situació:

.. image:: _images/constructors_06.svg
   :align: center
   :width: 75%

Així, per executar ``return aquest.vides``, només hem d'accedir al
``vides`` de la posició ``@1000``, obtenir el valor ``7`` i retornar-lo.

En tornar al ``main()`` a la *seva* variable ``vides`` li quedarà assignat
el valor ``7`` retornat per ``getVides()``, el que ens deixarà novament:

.. image:: _images/constructors_03.svg
   :align: center
   :width: 75%


En resum: podem inicialitzar els valors dels camps de les instàncies de
``GatRenat`` tant directament a la línia de la declaració, com dins d'aquesta
mena de *mòdul* que es diu ``GatRenat()``.

Ja va sent hora de que el deixem d'anomenar *mena de mòdul* i li posem el nom
que li correspon: *constructor*.

Els *constructors* en Java tenen la forma d'un *mòdul* amb les següents
particularitats:

* el seu nom coincideix amb el de la classe

* no té valor de retorn, ni tant sols ``void``.

Potser t'estaràs preguntant: com és possible que fins ara hagi estat
instanciant gats Renats sense definir constructor? La resposta és: si no
explicitem un constructor, Java ens n'afegeix un automàticament. És a dir,
les següents dues definicions són equivalents:

.. code-block:: java

    public class Garfield {
        // no cal indicar el constructor si no ha de fer res especial
    }

.. code-block:: java

    public class Garfield {
        public Garfield() {
            // no cal posar res aquí si no ha de fer res especial
        }
    }

|exerciseicon__T| :doc:`exercici_04_20_constructor_posicio`


Els constructors poden tenir paràmetres
=======================================

Una nova versió del codi anterior:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat(int)
        +getVides(): int
     }
     @enduml


.. code-block:: java
    :linenos:
    :emphasize-lines: 3, 9

    public class GatRenat {
        private int vides;
        public GatRenat(int novesVides) {
            vides = novesVides;
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Aquesta nova versió presenta una novetat respecte l'anterior: El constructor
*rep* el valor amb el que ha d'inicialitzar les vides.

Fins ara, el constructor del nostre Renat no tenia cap paràmetre, però no
hi ha cap raó per que no els pugui tenir.

Que aquest nou constructor tingui un paràmetre té una implicació
important: podem decidir el nombre de vides inicial en el moment de la
creació!

Una altra implicació és que ara, per crear una instància de ``GatRenat`` ens
veiem en l'obligació d'indicar el valor inicial.

|exerciseicon__T| :doc:`exercici_04_21_constructor_parametritzat`

El constructor sense paràmetres se'l coneix com a *constructor per
defecte* mentre que el paràmetritzat se'l coneix com a *constructor
específic*. Java només ens afegirà automàticament el constructor per
defecte i ho farà només en el cas que no li indiquem nosaltres un altre
constructor, sigui per defecte o sigui específic.


Vides desprotegides en néixer!
==============================

El constructor específic que hem creat a la versió anterior obre la porta
a errors: ara podem fer que ``vides`` tingui un valor inadequat des del
principi!

Per aquesta raó, ens caldrà protegir-la. Per exemple:

.. code-block:: java
    :linenos:
    :emphasize-lines: 4

    public class GatRenat {
        private int vides = 7;
        public GatRenat(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
        public int getVides() { return vides; }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Fixa't que ara tornem a inicialitzar ``vides`` al valor per defecte ``7`` en
comptes del base ``0``. El constructor únicament posarà un valor diferent de
``vides`` en el cas que el que se li demani sigui considerat vàlid.

Encara millor, si volem que es pugui modificar ``vides`` després de la
inicialització, podem afegir el *setter* corresponent i aprofitar-ho des del
constructor!

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat(int)
        +getVides(): int
        +setVides(int)
     }
     @enduml


.. code-block:: java
    :linenos:
    :emphasize-lines: 4, 7-11

    public class GatRenat {
        private int vides = 7;
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

Nota: en afegir el *setter* hem perdut la propietat d'immutabilitat que
gaudíem. Si la volguéssim continuar tenint, podríem simplement declarar el
*setter* com a privat.

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -setVides(int)
     }
     @enduml


.. code-block:: java

        private void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }

|exerciseicon__T| :doc:`exercici_04_22_constructor_posicio`

En resum: hem de vigilar cada cop que oferim una nova possibilitat de
donar valor a un camp, que no estiguem obrint una porta per què l'estat de
la instància pugui quedar inconsistent.


``this``: La referència *misteriosa*
====================================

Ja hem parlat (`Un lleuger canvi`_) del ``this``. Atenció a
aquesta nova definició de ``GatRenat``:

.. code-block:: java
    :linenos:
    :emphasize-lines: 9

    public class GatRenat {
        private int vides = 7;
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int vides) {
            if (vides >= 0)  {
                this.vides = vides;
            }
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

La nova versió incorpora ``this`` al *setter** per diferenciar el camp
``vides`` del paràmetre ``vides``.

És clar, si no li posem, estaríem parlant de la mateixa variable: el
paràmetre ``vides`` i no la propietat ``vides``!. És a dir, que estaríem
fent ``vides = vides;`` cosa poc productiva, no creus?

El codi també funcionaria de la següent manera:

.. code-block:: java
    :linenos:
    :emphasize-lines: 4, 7

    public class GatRenat {
        private int vides;
        public GatRenat(int vides) {
            this.setVides(vides);
        }
        public int getVides() {
            return this.vides;
        }
        public void setVides(int vides) {
            if (vides >= 0) {
                this.vides = vides;
            }
        }
        public static void main(String[] args) {
            GatRenat renat;
            renat = new GatRenat(7);
            renat.setVides(6);
            int vides = renat.getVides();
            System.out.printf("Vides: %d%n", vides);
        }
    }

La referència ``this`` ens ve de *regal* a tots els mòduls de la classe que no
estiguin marcats amb la paraula ``static``. És a dir, ``main()`` no pot fer
servir ``this``.

Així, ``this`` fa referència a la mateixa instància que la variable a
partir de la que fem la crida:

.. image:: _images/constructors_07.svg
   :align: center
   :width: 75%


|exerciseicon__T| :doc:`exercici_04_23_aquesta_posicio`

Més d'un constructor
====================

Ara que ja sabem que podem tenir un constructor per defecte però també un
d'específic, ens podem plantejar si seria possible disposar dels dos.
Per exemple, en el cas del Gat Renat, el més normal és que hagi de néixer
amb 7 vides. No deixa de ser incòmode haver d'indicar 7 cada cop que en
volem un!

Això amb Java és possible gràcies al que es coneix com a
*sobrecàrrega* que vam descobrir a :doc:`aquest exercici
<exercici_04_17_assessinable>` sinó :doc:`abans <exercici_02_24_es_enter>`.

Considera aquesta nova versió del nostre amic:

.. uml::
    :align: center

     @startuml
     hide circle
     skinparam monochrome true
     skinparam classAttributeIconSize 0

     class GatRenat {
        -vides
        +GatRenat()
        +GatRenat(int)
        +getVides(): int
        +setVides(int)
     }
     @enduml

.. code-block:: java
    :linenos:
    :emphasize-lines: 3, 6, 16, 17

    public class GatRenat {
        private int vides = 7;
        public GatRenat() {
            setVides(7);
        }
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
        public static void main(String[] args) {
            GatRenat renatI = new GatRenat();
            GatRenat renatII = new GatRenat(8);
            System.out.printf("Renat I té %d vides%n", renatI.vides);
            System.out.printf("Renat II té %d vides%n", renatII.vides);
        }
    }

Fixa't que els dos constructors fan servir el *setter*. Encara que sabem
que 7 és un valor vàlid per vides, és una bona pràctica fer-ho així, doncs
ens assegura que si mai ens calgués fer res especial amb el cas del 7,
només ho hauríem de fer en un punt (el *setter*)

Encara podem fer-ho més modular, fent servir la nostra misteriosa
referència ``this``. Aquest cop amb un format encara més inquietant: com a
*crida*!

.. code-block:: java
    :linenos:
    :emphasize-lines: 4

    public class GatRenat {
        private int vides = 7;
        public GatRenat() {
            this(7);
        }
        public GatRenat(int vides) {
            setVides(vides);
        }
        public int getVides() { return vides; }
        public void setVides(int novesVides) {
            if (novesVides >= 0)  {
                vides = novesVides;
            }
        }
    }

La crida de la línia 7 està fent referència al constructor específic.
Per poder fer servir ``this()`` cal tenir present que ha de ser la primera
línia del cos del constructor, altrament ``javac`` es queixarà.

|exerciseicon__T| :doc:`exercici_04_24_molts_constructors`

|exerciseicon__T| :doc:`exercici_04_25_hora`

|exerciseicon___| :doc:`exercici_04_26_resum`
