###############
El tipus String
###############

Ja hem vist a :doc:`tipus_de_tipus`, els Strings no són un tipus primitiu a
Java, sinó *objectes*. És a dir, una variable de tipus String **no** conté
directament el text corresponent al seu valor, sinó una referència a la
posició de memòria on es troba el text.

Aquesta *peculiaritat* fa que els Strings no es facin servir exactament de
la mateixa manera amb que usàvem variables de tipus primitiu.

Amb tot, el tipus String és tan utilitzat que els dissenyadors de Java
s'han pres moltes molèsties en fer-los més usables per nosaltres.
D'aquesta manera, ens trobarem que aquest tipus té un tracte especial pel
llenguatge.

A aquesta secció trobaràs una visió resumida de les operacions més
bàsiques que freqüentment fem amb Strings. Algunes ja les hem vistes però
d'altres te les presento per primer cop.


Concatenació de Strings
=======================

Java ens ofereix l'operador ``+`` per concatenar strings.
Així

.. code-block:: console
    :emphasize-lines: 2

    jshell> "hola" + " i " +  "adeu"
    $1 ==> "hola i adeu"

Java ens permet concatenar automàticament altres tipus de dades. Per
exemple, amb un caràcter:

.. code-block:: console
    :emphasize-lines: 2

    jshell> String text = "ho" + 1 + 'a';
    text ==> "ho1a"

Compte, però, en l'ordre en que li demanem les coses. Per exemple:

.. code-block:: console
    :emphasize-lines: 2

    jshell> String text = 'a' + 1 + "oh";
    text ==> "98oh"

Aquí, el caràcter ``'a'`` ha estat considerat com un número (el codi ASCII
de la 'a' és el 97). Java ha sumat 97 més 1 i, el resultat, l'ha convertit
a String per concatenar-ho a `"oh"`!

Ho podem solucionar, per exemple, explicitant-li a Java que volem que faci
servir la concatenació de Strings tot afegint la cadena buida a l'inici.

.. code-block:: console
    :emphasize-lines: 2

    jshell> String text = "" + 'a' + 1 + "oh";
    text ==> "a1oh"


Comparació d'igualtat
=====================

Amb els tipus primitius (a excepció del nombres amb coma flotant)
l'operador d'igualtat ``==`` ens permet decidir si un valor és igual a un
altre. Això no és possible amb els Strings ja que la variable no *conté*
el text sinó una referència a aquest. Per tant, ``==`` resultarà cert
només si els texts dels dos strings a comparar es troben a la mateixa
posició de memòria, cosa que sovint no serà certa.

Una comparació amb resultat sorprenent
--------------------------------------

Considera el següent programa:

.. code-block:: java
   :linenos:

    public class Hola {
        public static void main(String[] args) {
            String literal1 = "hola";
            String literal2 = "hol" + 'a';
            System.out.print("Introdueix un text: ");
            String referencia = Entrada.readLine();
            System.out.println("Comparem literals             : \"" +
                                literal1 + "\" == \"" + 
                                literal2 + "\" → " + 
                                (literal1 == literal2)
                              );
            System.out.println("Comparem literals i referència: \"" + 
                                literal1 + "\" == \"" +
                                referencia + "\" → " + 
                                (literal1 == referencia)
                              );
        }
    }

Ara, considera aquesta interacció:

.. code-block:: console
    :emphasize-lines: 2, 4, 5

    $ java Hola 
    Introdueix un text
    hola
    Comparem literals             : "hola" == "hola" → true
    Comparem literals i referència: "hola" == "hola" → false

Què ha passat?

En el primer cas, Java considera que ``"hola"`` és igual a ``"hola"``.
Sembla que és el que tothom esperaria malgrat els valors de
``literal1`` i ``literal2`` han estat construïts de manera diferent.

En canvi, quan comparem ``literal1`` amb ``referencia``, el resultat és
fals malgrat tots dos contenen el mateix text ``"hola"``!

L'explicació del segon cas és molt senzilla.

Com sabem, Java no guarda el text d'un String directament a la seva
variable. En comptes, guarda una referència al lloc on es troba el text en
memòria.

Suposem que el text de ``literal1`` està guardat a la posició *@1000*.
Vindria a ser com si el valor de ``literal1`` fos ``1000``. Quan el
programa llegeix el valor de l'entrada estàndard, aquest pot ser qualsevol
text, potser també ``"hola"``. Java guarda aquest valor a una nova
posició, suposem *@5000*. Així, ``referencia`` tindria com a valor
``5000``.  Quan comparem ``literal1 == referencia`` Java entén que
volem saber si ``1000 == 5000`` cosa que, evidentment, no és certa.

Però, llavors, perquè ``literal1 == literal2`` sí funciona? Doncs
resulta que el compilador de Java que estic fent servir, és prou
*intel·ligent* com per realitzar la concatenació del segon text i
adonar-se que ja disposa d'un text igual a la posició *@1000* i, per
tant, assigna a ``literal2`` la mateixa posició.

Si ho representem amb la nostra simplificació de la memòria ens trobem
quelcom similar a:

+-----------------------+---------+--------------------------+
|   variable            | posició |   valor                  |
+=======================+=========+==========================+
| String literal1       | @100    |   ``1000``               |
+-----------------------+---------+--------------------------+
| String literal2       | @101    |   ``1000``               |
+-----------------------+---------+--------------------------+
| String referencia     | @102    |   ``5000``               |
+-----------------------+---------+--------------------------+
| …                                                          |
+-----------------------+---------+--------------------------+
|                       | @1000   |   ``"hola"``             |
+-----------------------+---------+--------------------------+
| …                                                          |
+-----------------------+---------+--------------------------+
|                       | @5000   |   ``"hola"``             |
+-----------------------+---------+--------------------------+
| …                                                          |
+-----------------------+---------+--------------------------+

Fixa't que les variables ``literal1`` i ``literal2`` tenen el mateix
valor ``@1000`` mentre que ``referencia`` té referència a un altre valor,
malgrat les posicions ``@1000`` i ``@5000`` al final tenen el mateix
valor. ``equals()`` és capaç de comparar els texts apuntats pels valors dels
dos Strings, en comptes de les posicions on es troben.

Se t'acut perquè Java no intenta fer aquesta optimització amb el text que
llegeix de l'entrada estàndard? Pista: qui s'espera amb la primera
optimització i qui s'esperaria amb la segona?

Comparem correctament els Strings
---------------------------------

La manera **correcta** i **segura** de comparar dos Strings per igualtat és la següent:

.. code-block:: java
   :linenos:

    public class Hola {
        public static void main(String[] args) {
            String literal1 = "hola";
            String literal2 = "hol" + 'a';
            System.out.print("Introdueix un text: ");
            String referencia = Entrada.readLine();
            System.out.println("Comparem literals             : \"" +
                                literal1 + "\" == \"" + 
                                literal2 + "\" → " + 
                                literal1.equals(literal2)
                              );
            System.out.println("Comparem literals i referència: \"" + 
                                literal1 + "\" == \"" +
                                referencia + "\" → " + 
                                literal1.equals(referencia)
                              );
        }
    }

Ara, la mateixa interacció que abans resulta així:

.. code-block:: console
    :emphasize-lines: 2, 3

    $ java Hola 
    Comparem literals             : "hola" == "hola" → true
    Comparem literals i referéncia: "hola" == "hola" → true


.. important:: Per evitar problemes, en Java compararem Strings **sempre**
               amb ``equals()``.


Conversions
===========

La API de Java ens ofereix diferents maneres per a realitzar conversions
entre els diferents tipus primitius i els Strings. Ja les hem vist en
funcionament abans. Recordem algunes:

.. code-block:: java
    :linenos:

    int valorEnter = Integer.parseInt("12345");
    double valorDecimal = Double.parseDouble("123.45");
    String cadenaEntera = String.valueOf(valorEnter);
    String cadenaDecimal = String.valueOf(valorDecimal);
    String unaAltraManera = "" + valorEnter;    // aprofita la concatenació
    String encaraUnaAltra = Integer.toString(valorEnter);

Utilitats
=========

Els Strings disposen de moltes utilitats que permeten manipular-los.

Per exemple,``startsWith()``: permet saber si el text comença amb un determinat text.
Podem usar aquesta utilitat, per exemple, de la següent manera:

  .. code-block:: console
      :emphasize-lines: 2, 5

      jshell> "hola".startsWith("ho")
      $1 ==> true

      jshell> "adéu".startsWith("ho")
      $2 ==> false

Anirem coneixent-les de mica en mica.

Construcció de Strings
======================

De vegades ens pot ser útil construir un String a partir de diferents
valors. Una manera molt còmoda de fer-ho és aprofitar la funció
``String.format()`` que espera com a paràmetres un String que defineix un
patró amb marques de variables més tants valors com hi hagi a les marques
del String.

Per exemple, considera el següent codi:

   .. code-block:: java
    :linenos:

    int edat = 19;
    String nom = "Nefertiti";
    String missatge = String.format("L'edat de %s és %d%n", nom, edat);

    // missatge.equals("L'edat de Nefertiti és 19\n")

Fixa't com el nom ve a substituir el ``%s`` del text, mentre que
l'edat apareix en comptes de ``%d``. El ``%n`` per la seva banda, escriu un
salt de línia que en sistemes tipus unix/linux correspondria ``\n`` 

Trobaràs tot el detall sobre els elements que poden aparèixer dins del
patró de ``String.format()`` a la secció `Format String Syntax
<http://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html#syntax>`_.


Permet-me un exemple una mica més sofisticat fent servir l'operador
ternari ``?:``.

.. code-block:: java
   :linenos:

    int edat = 19;
    String nom = "Nefertiti";
    String cognoms = "Peláez Ramírez";
    String missatge = String.format("%s %s és %s d'edat doncs té %d any%s%n",
                                    nom, cognoms, 
                                    edat < 18 ? "menor": "major", 
                                    edat, 
                                    edat == 1 ? "" : "s");

    // missatge.equals("Nefertiti Peláez Ramírez és major d'edat doncs té 19 anys\n")

.. tip:: Un operador ternari

    Fins ara potser no t'havies trobat amb l'expressió ``edat < 18 ? "menor": "major"``.
    Es tracta d'un operador que presenta tres operands ``edat < 18``,
    ``menor`` i ``major``.

    Bàsicament fa que si la condició és certa, resulta en el segon operand
    (en aquest cas ``"menor"``) i si és falsa, en el tercer.


Per saber més
=============

Hi ha tot un munt d'altres possibilitats de manipulació i de conversió a i de Strings a:

* API `Strings <https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/String.html>`_
* API `Integer <https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Integer.html>`_
* API `Double <https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Double.html>`_
* API `Character <https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/lang/Character.html>`_


|exerciseicon__T| :doc:`exercici_14_02_informestring`

