####################
El bucle s'ha acabat
####################

El mateix que ens passava amb la finalització d'un programa, ens passa de
vegades dins d'un bucle.

Per exemple, considera el següent programa

.. code-block:: java
    :linenos:

    /*
     * Programa que demana un text i diu si aquest conté o no una 'J'
     */
    public class ConteJ {
        public static void main(String[] args) {
            System.out.println("Text?");
            String text = Entrada.readLine();
            boolean conteJ = false;
            for (int i=0; i < text.length(); i++) {
                if (text.charAt(i) == 'J') {
                    conteJ = true;
                }
            }
            if (conteJ) {
                System.out.println("Conté J");
            } else {
                System.out.println("No conté J");
            }
        }
    }

Fixa't que el programa demana un text i el recorre cercant una ``'J'``. Un cop
ha trobat una, continua recorrent-lo fins el final, això sí, sense
molestar-se en mirar si hi ha o no més ``'J'``.

El codi es podria simplificar molt si fem servir una bona expressió
booleana

En concret, considera el fragment de codi següent:

.. code-block:: java

    if (text.charAt(i) == 'J') {
        conteJ = true;
    }

El codi anterior el podem simplificar amb una única línia:

.. code-block:: java

    conteJ = conteJ || text.charAt(i) == 'J';

Si t'agrada aquesta versió, fes-la servir.

Imagina que el text de l'entrada fos simplement ``"Java"``. Sabem que la
``'J'`` s'ha trobat al primer caràcter i que donarem encara tres iteracions
més abans de poder donar un resultat que ja sabem. Total, tres iteracions
de més no sembla un gran problema… oi?

Si el text hagués estat el contingut d'un llibre de +800 pàgines que comença
amb la paraula *Java*, potser les iteracions extres no ens semblarien tan
poca cosa.

``while`` to the rescue
=======================

Per resoldre aquest tipus de problemes en els que no cal arribar al final,
podríem fer servir *l'altre* bucle: el ``while``.

.. code-block:: java
    :linenos:

    /*
     * Programa que demana un text i diu si aquest conté o no una 'J'
     */
    public class ConteJ {
        public static void main(String[] args) {
            System.out.println("Text?");
            String text = Entrada.readLine();
            boolean conteJ = false;
            int i = 0;
            while (! conteJ && i < text.length()) {
                conteJ = text.charAt(i) == 'J';
                i++;
            }
            if (conteJ) {
                System.out.println("Conté J");
            } else {
                System.out.println("No conté J");
            }
        }
    }

La solució és prou senzilla però perd l'elegància dels recorreguts amb
``for``.

Perquè no *finalitzant*
=======================

El ``for`` era adequat per *recórrer* el text. El que ens caldria és una
manera de finalitzar quan sapiguem el resultat.

No podríem tornar a fer servir ``return``?

.. code-block:: java
    :linenos:

    /*
     * Programa que demana un text i diu si aquest conté o no una 'J'
     */
    public class ConteJ {
        public static void main(String[] args) {
            System.out.println("Text?");
            String text = Entrada.readLine();
            for (int i=0; i < text.length(); i++) {
                if (text.charAt(i) == 'J') {
                    System.out.println("Conté J");
                    return;
                }
            }
            System.out.println("No conté J");
        }
    }

En aquest cas sí. Al cap i a la fi, en mostrar el missatge, ja hem acabat.
Què passaria, però, si després del bucle haguéssim de fer més coses?
Passaria que ens tocaria repetir el que vingués a continuació, una vegada
abans del ``return`` i una altra al final del bucle. El ``return`` és
massa dràstic i ens obliga a fer duplicacions de codi si el volem fer
servir.

*Trenquem* el bucle
===================

En comptes de finalitzar, el que volem és simplement *trencar* el bucle.

.. code-block:: java
    :linenos:

    /*
     * Programa que demana un text i diu si aquest conté o no una 'J'
     */
    public class ConteJ {
        public static void main(String[] args) {
            System.out.println("Text?");
            String text = Entrada.readLine();
            boolean conteJ = false;
            for (int i=0; i < text.length(); i++) {
                if (text.charAt(i) == 'J') {
                    conteJ = true;
                    break;
                }
            }
            if (conteJ) {
                System.out.println("Conté J");
            } else {
                System.out.println("No conté J");
            }
        }
    }

Doncs sí, el ``break``. Ja el coneixes si vas fer
l\':doc:`exercici_11_08_diessetmana_switch`. En aquella ocasió, el
``break`` servia per no continuar executant a partir d'haver detectat un
cas cert. En el cas dels bucles, la funció del ``break`` és similar:
trencar el flux normal d'execució i anar a la instrucció següent un cop
abandonat el bucle.

En arribar al ``break``, Java surt del bucle més immediat tant si ha
arribat al final com si no.

Això de *més immediat* es refereix a que, en cas que hi hagi un bucle dins
d'un altre, si fem ``break`` sortim del primer però seguim al segon.

.. code-block:: console
    :emphasize-lines: 8-

    jshell> for (int i=1; i<=3; i++) {
       ...>     System.out.println("i:" + i);
       ...>     for (int j=1; j <=1000; j++) {
       ...>         System.out.println("j:" + j);
       ...>         break;
       ...>     }
       ...> }
    i:1
    j:1
    i:2
    j:1
    i:3
    j:1

Fixa't al codi anterior com la ``j`` no passa mai de l\'``1`` doncs en
mostrar el primer valor, surt del bucle amb ``break``. La ``i``, però, si
aconsegueix passar per tots els valors del recorregut.

Trencant el ``while``
=====================

Malgrat pot semblar que a ``while`` no li cal un ``break`` donat que
disposem de la condició per poder controlar quan ha de finalitzar, el cert
és que pot arribar a resultar molt còmode utilitzar-lo en certes
situacions.

Per exemple, recordem el codi que varem veure a :doc:`while_redundancia`:

.. code-block:: java
    :linenos:

    public class SumaPositius {
        public static void main(String[] args) {
            int suma = 0;
            int valor = 0;
            while (valor >= 0) {
                System.out.println("Introdueix valor");
                valor = Integer.parseInt(Entrada.readLine());
                if (valor >= 0) {
                    suma = suma + valor;
                }
            }
            System.out.println("La suma és " + suma);
        }
    }

Ara que disposem del ``break``, podríem eliminar la redundància de la
comprovació de la següent manera:

.. code-block:: java
    :linenos:

    public class SumaPositius {
        public static void main(String[] args) {
            int suma = 0;
            while (true) {
                System.out.println("Introdueix valor");
                int valor = Integer.parseInt(Entrada.readLine());
                if (valor < 0) {
                    break;
                }
                suma = suma + valor;
            }
            System.out.println("La suma és " + suma);
        }
    }

Podríem dibuixar-ho de la següent manera:

.. graphviz::
    :align: center

    digraph {
        inici [shape="box", style=rounded];
        instruccio1 [label="suma = 0", shape="rectangle", style=""];
        instruccio2 [label="llegeix valor", shape="rectangle", style=""]
        condicio2 [label="valor < 0", shape="diamond", style=""];
        instruccio3 [label="suma = suma + valor", shape="rectangle", style=""]
        instruccio4 [label="escriu suma", shape="rectangle", style=""]
        final[shape="box", style=rounded];

        inici -> instruccio1
        instruccio1 -> instruccio2;
        instruccio2 -> condicio2;
        condicio2 -> instruccio4 [label="cert", color="red"];
        condicio2 -> instruccio3 [label="fals"];
        instruccio3 -> instruccio2;

        instruccio4 -> final;
    }


Abans de la comoditat d'escriure'l, però, cal tenir sempre en compte
sempre la llegibilitat del nostre codi. En aquest cas, la diferència és
petita.

|exerciseicon__T| :doc:`exercici_14_19_contedarrer`

Bucle infinit
=============

Només un petit apunt respecte el bucle infinit ``while (true)`` que
acabem de veure.

Aquest ús en alguns estils de programació està malament vist. Es considera poc
llegible i una font d'errors. Per altres, però, és un bucle perfectament
normal. Fins i tot es considera una variant de bucle per si mateixa, per la que
alguns llenguatges ofereixen estructures específiques. Per exemple *Ruby* i
*Rust* ofereixen la paraula reservada ``loop``.

Per aquest curs, l'ús dels bucles infinits és acceptable. Només vigila que
en algun moment els *trenques* si vols que els teus programes finalitzin algun
dia.
